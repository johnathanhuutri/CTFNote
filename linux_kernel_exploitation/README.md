# Linux Kernel Exploitation Note

## Assembly code in C

In C, we can use function `__asm__ ()` to write assembly code.

### Format

Here is an example:

```c
#include <stdio.h>

int main() {
    __asm__ (
        ".intel_syntax noprefix;"
        ".att_syntax;"
        :		// Output operand
        :		// Input operand
        :		// Register that will be modify when executing these assembly code
    );
    return 0;
}
```

Because gcc uses AT&T syntax as default but I want to use Intel syntax instead, I will need to specify that I will use Intel syntax without prefix:
```
".intel_syntax noprefix;"
```

After writing assembly code, I just need to switch back to AT&T syntax so that gcc can understand:
```
".att_syntax;"
```

### Modify registers

Here is an example:

```c
#include <stdio.h>

int main() {
    __asm__ (
        ".intel_syntax noprefix;"
        "mov rax, 1;"
        "xor rbx, rax;"
        "add cx, 2;"
        "sub edx, ecx;"
        ".att_syntax;"
        :		// Output operand
        :		// Input operand
        : "rax", "rbx", "rcx", "rdx"		// Register that will be modify
    );
    return 0;
}
```

As you can see, when executing assembly code, we changed rax, rbx, rcx and rdx so we specify those 4 registers will be changed that the compiler know to use other register for storing value instead of those 4 ones.

### Input operand

Here is an example:

```c
#include <stdio.h>

int main() {
    char *s = "Hello World!\n";
    __asm__ (
    	".intel_syntax noprefix;"
    	"mov rax, 1;"
    	"xor rdi, rdi;"
    	"mov rsi, (%0);"
    	"mov rdx, 13;"
    	"syscall;"
    	".att_syntax;"
    	:		// Output operand
    	: "r" (s)							// Input operand
    	: "rax", "rdi", "rsi", "rdx"		// Register that will be modify
	);
    return 0;
}
```

We defined a string pointer `s` that point to string `Hello World!\n`. Now we can pass that var into our assembly code by defining `: "r" (s)` and use that var as `(%1)`. `"r"` means program can use any register to store var `s` and use it. If we want to pass more variable into assembly code, below is another example:

```c
#include <stdio.h>

int main() {
    char *s1 = "Hello ";
    char *s2 = "World!\n";
    __asm__ (
    	".intel_syntax noprefix;"
    	"mov rax, 1;"
    	"xor rdi, rdi;"
    	"mov rsi, (%0);"
    	"mov rdx, 6;"
    	"syscall;"
    	"mov rax, 1;"
    	"xor rdi, rdi;"
    	"mov rsi, (%1);"
    	"mov rdx, 7;"
    	"syscall;"
    	".att_syntax;"
    	:		// Output operand
    	: "r" (s1), "r" (s2)				// Input operand
    	: "rax", "rdi", "rsi", "rdx"		// Register that will be modify
	);
    return 0;
}
```

With variable is ordered, accessing `(%0)` will get var `s1` and accessing `(%1)` will get var `s2` and again, `"r"` means program can use any register to store var `s1`, `s2` and use it.

Hmmm, is it a bit too hard to remember if there are plenty of variables that you want to pass to? Well we can define a tag `str` (only assembly can understand) for each variable that we pass into, let's try with example above:

```c
#include <stdio.h>

int main() {
    char *s1 = "Hello ";
    char *s2 = "World!\n";
    __asm__ (
    	".intel_syntax noprefix;"
    	"mov rax, 1;"
    	"xor rdi, rdi;"
    	"mov rsi, %[a];"
    	"mov rdx, 6;"
    	"syscall;"
    	"mov rax, 1;"
    	"xor rdi, rdi;"
    	"mov rsi, %[b];"
    	"mov rdx, 7;"
    	"syscall;"
    	".att_syntax;"
    	:		// Output operand
    	: [a] "r" (s1), [b] "r" (s2)		// Input operand
    	: "rax", "rdi", "rsi", "rdx"		// Register that will be modify
	);
    return 0;
}
```

We define `s1` with tag `a` and `s2` with tag `b` so the code is just similar instead of the way we use `a` and `b`.

### Output operand

Now if we want to get the result back, here is an example:

```c
#include <stdio.h>

int main() {
	int a = 100;
	long b = 200;
	long res = 0;
    __asm__ (
    	".intel_syntax noprefix;"
    	"mov eax, %[vara];"
    	"add rax, %[varb];"
    	"mov %[varres], rax;"
    	".att_syntax;"
    	: [varres] "=r" (res)					// Output operand
    	: [vara] "r" (a), [varb] "r" (b)		// Input operand
    	: "rax", "rdi", "rsi", "rdx"			// Register that will be modify
	);    return 0;
}
```

Now we pass in 2 vars `a` (tag `vara`) and `b` (tag `varb`), we do a simple add and return value to var `res` (tag `varres`). Remember with output operand, we will use `=r` instead of `r`.

### Specific register

With those example, we used `r` or `=r` but what if we want to use specify register? Well, of course you can! Let's say you want return value at `rax` so just change `=r` into `=a`:

```c
#include <stdio.h>

int main() {
	int a = 100;
	long b = 200;
	long res = 0;
    __asm__ (
    	".intel_syntax noprefix;"
    	"mov eax, %[vara];"
    	"add rax, %[varb];"
    	"mov %[varres], rax;"
    	".att_syntax;"
    	: [varres] "=a" (res)					// Output operand (Changed into "=a")
    	: [vara] "r" (a), [varb] "r" (b)		// Input operand
    	: "rax", "rdi", "rsi", "rdx"			// Register that will be modify
	);    return 0;
}
```

Here are some register that I know we can change into:
- `"a"` or `"=a"`: rax
- `"b"` or `"=b"`: rbx
- `"c"` or `"=c"`: rcx



